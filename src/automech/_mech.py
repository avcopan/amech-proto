"""Definition and core functionality of the mechanism data structure."""

import dataclasses
import itertools
import textwrap
from collections.abc import Sequence
from pathlib import Path

import automol
import pandas
import polars
import pyvis

# from IPython import display as ipd
from . import data, schema
from .schema import Reaction, ReactionDataFrame, Species, SpeciesDataFrame
from .util import df_


@dataclasses.dataclass
class Mechanism:
    """A chemical kinetic mechanism."""

    reactions: ReactionDataFrame
    species: SpeciesDataFrame

    def __repr__(self):
        rxn_df_rep = textwrap.indent(repr(self.reactions), "  ")
        spc_df_rep = textwrap.indent(repr(self.species), "  ")
        rxn_rep = textwrap.indent(f"reactions=DataFrame(\n{rxn_df_rep}\n)", "  ")
        spc_rep = textwrap.indent(f"species=DataFrame(\n{spc_df_rep}\n)", "  ")
        return f"Mechanism(\n{rxn_rep},\n{spc_rep},\n)"


# constructors
def from_data(inp, spc_inp) -> Mechanism:
    """Contruct a mechanism object from data.

    :param inp: A reactions table, as a CSV file path or dataframe
    :param spc_inp: A species table, as a CSV file path or dataframe
    :param validate: Validate the data?
    :return: The mechanism object
    """
    rxn_df = df_.from_csv(inp) if isinstance(inp, str) else inp
    spc_df = df_.from_csv(spc_inp) if isinstance(spc_inp, str) else spc_inp
    rxn_df = schema.reaction_table(rxn_df)
    spc_df = schema.species_table(spc_df)
    return Mechanism(reactions=rxn_df, species=spc_df)


def add_species(
    mech: Mechanism,
    id_: str,
    id_typ: str = Species.smi,
    name: str | None = None,
    spin: int | None = None,
    charge: int | None = None,
) -> Mechanism:
    """Add a new species to a mechanism.

    :param mech: A mechanism
    :param id_: The ID of the species to add, either AMChI or SMILES
    :param id_typ: The type of the ID, 'smi' or 'chi
    :param name: Optionally, specify the species name to override the autogenerated one
    :return: The updated mechanism
    """
    id_typs = (Species.smi, Species.chi)
    assert id_typ in id_typs, f"id_typ {id_typ} not in {id_typs}"

    chi = id_ if id_typ == Species.chi else automol.smiles.amchi(id_)
    smi = id_ if id_typ == Species.smi else automol.amchi.smiles(id_)
    row = pandas.DataFrame(
        {
            Species.chi: [chi],
            Species.smi: [smi],
            Species.name: [automol.amchi.chemkin_name(chi) if name is None else name],
            Species.spin: [automol.amchi.guess_spin(chi) if spin is None else spin],
            Species.charge: [0 if charge is None else charge],
        }
    )

    spc_df = pandas.concat([mech.species, row], ignore_index=True)
    return from_data(mech.reactions, spc_df)


def from_smiles(
    smis: Sequence[str],
    rxn_smis: Sequence[str] = (),
    name_dct: dict[str, str] | None = None,
    spin_dct: dict[str, int] | None = None,
    charge_dct: dict[str, int] | None = None,
) -> Mechanism:
    """Generate a mechanism, using SMILES strings for the species names.

    If `name_dct` is `None`, CHEMKIN names will be auto-generated.

    :param smis: The species SMILES strings
    :param rxn_smis: Optionally, the reaction SMILES strings
    :param name_dct: Optionally, specify the name for some molecules
    :param spin_dct: Optionally, specify the spin state (2S) for some molecules
    :param charge_dct: Optionally, specify the charge for some molecules
    :return: The mechanism
    """
    name_dct = {} if name_dct is None else name_dct
    spin_dct = {} if spin_dct is None else spin_dct
    charge_dct = {} if charge_dct is None else charge_dct

    # Build the species dataframe
    chis = list(map(automol.smiles.amchi, smis))
    chi_dct = dict(zip(smis, chis, strict=True))
    name_dct = {chi_dct[k]: v for k, v in name_dct.items() if k in smis}
    spin_dct = {chi_dct[k]: v for k, v in spin_dct.items() if k in smis}
    charge_dct = {chi_dct[k]: v for k, v in charge_dct.items() if k in smis}
    data_dct = {Species.smi: smis, Species.chi: chis}
    dt = schema.types([Species], data_dct.keys())
    spc_df = polars.DataFrame(data=data_dct, schema=dt)
    spc_df = schema.species_table(
        spc_df, name_dct=name_dct, spin_dct=spin_dct, charge_dct=charge_dct
    )

    # Build the reactions dataframe
    trans_dct = df_.lookup_dict(spc_df, Species.smi, Species.name)
    rxn_smis_lst = list(map(automol.smiles.reaction_reactants_and_products, rxn_smis))
    eqs = [
        data.reac.write_chemkin_equation(rs, ps, trans_dct=trans_dct)
        for rs, ps in rxn_smis_lst
    ]
    data_dct = {Reaction.eq: eqs}
    dt = schema.types([Reaction], data_dct.keys())
    rxn_df = polars.DataFrame(data=data_dct, schema=dt)
    print(eqs)
    print(rxn_df)
    return from_data(rxn_df, spc_df)


# getters
def species(mech: Mechanism) -> polars.DataFrame:
    """Get the species dataframe for a mechanism.

    :param mech: The mechanism
    :return: The mechanism's species dataframe
    """
    return mech.species


def reactions(mech: Mechanism) -> polars.DataFrame:
    """Get the reactions dataframe for a mechanism.

    :param mech: The mechanism
    :return: The mechanism's reactions dataframe
    """
    return mech.reactions


# transformations
def grow(
    mech: Mechanism,
    rxn_type: str,
    rct1s: Sequence[str] | None = None,
    rct2s: Sequence[str] | None = None,
    prds: Sequence[str] | None = None,
    id_: str = Species.smi,
    unimol: bool = True,
    bimol: bool = True,
) -> Mechanism:
    """Grow a mechanism by enumerating and adding reactions.

    :param mech: The mechanism
    :param rxn_type: The reaction type to enumerate
    :param rct1s: Optionally, require one reagent to match one of these identifiers
    :param rct2s: Optionally, require a second reagent to match one of these identifiers
    :param prds: Optionally, require a product to match one of these identifiers
    :param id_: The identifier type for species lists, 'smi' or 'chi'
    :param unimol: Include unimolecular reactions?
    :param bimol: Include bimolecular reactions?
    """
    spc_df = mech.species
    chi_dct = df_.lookup_dict(spc_df, id_, Species.chi)
    chi_conv_ = automol.smiles.amchi if id_ == Species.smi else lambda x: x

    r1_chis = list(spc_df[Species.chi] if rct1s is None else map(chi_dct.get, rct1s))
    r2_chis = list(spc_df[Species.chi] if rct2s is None else map(chi_dct.get, rct2s))
    p_chis = None if prds is None else list(map(chi_conv_, prds))

    rxns = ()
    if unimol:
        for chi in r1_chis:
            rxns += automol.reac.enumerate_from_amchis([chi], rxn_type=rxn_type)
    if bimol:
        for chi1, chi2 in zip(r1_chis, r2_chis, strict=True):
            rxns += automol.reac.enumerate_from_amchis([chi1, chi2], rxn_type=rxn_type)

    # prds = None if prds is None else
    print(mech)
    print(rxn_type)
    print(r1_chis)
    print(r2_chis)
    print(p_chis)


# properties
def display(
    mech: Mechanism,
    stereo: bool = True,
    exclude_formulas: tuple[str, ...] = ("H*", "OH*", "O2H*", "CH*"),
    out_name: str = "net.html",
    out_dir: str = ".automech",
) -> None:
    """Display the mechanism as a reaction network.

    :param mech: The mechanism
    :param stereo: Include stereochemistry in species drawings?, defaults to True
    :param exclude: Formula strings of molecules to exclude from the  network nodes,
        using * for wildcard stoichiometry, defaults to ("H*", "OH*", "O2H*", "CH*")
    :param out: The name of the HTML file to write the network visualization to
    """
    out_dir: Path = Path(out_dir)
    out_dir.mkdir(exist_ok=True)

    # Read in the mechanism data
    spc_df = species(mech)
    rxn_df = reactions(mech)

    # Handle excluded species
    excl_fmls = tuple(map(automol.form.from_string, exclude_formulas))

    def _is_excluded(row: Series):
        chi = row[Species.chi]
        fml = automol.amchi.formula(chi)
        if any(automol.form.match(fml, f) for f in excl_fmls):
            return True
        return False

    spc_df["excluded"] = spc_df.progress_apply(_is_excluded, axis=1)
    excl_names = list(spc_df[spc_df["excluded"]][Species.name])

    img_dir = Path("img")
    (out_dir / img_dir).mkdir(exist_ok=True)

    def _create_image(row: Series):
        chi = row[Species.chi]
        gra = automol.amchi.graph(chi, stereo=stereo)
        chk = automol.amchi.amchi_key(chi)
        svg_str = automol.graph.svg_string(gra, image_size=100)

        path = img_dir / f"{chk}.svg"
        with open(out_dir / path, mode="w") as file:
            file.write(svg_str)

        return str(path)

    spc_df["image_path"] = spc_df.progress_apply(_create_image, axis=1)

    net = pyvis.network.Network(directed=True, notebook=True, cdn_resources="in_line")

    def _add_node(row: Series):
        name = row[Species.name]
        smi = row[Species.smi]
        path = row["image_path"]
        if name not in excl_names:
            net.add_node(name, shape="image", image=path, title=smi)

    def _add_edge(row: Series):
        eq = row[Reaction.eq]
        rnames, pnames, _ = data.reac.read_chemkin_equation(eq)
        for rname, pname in itertools.product(rnames, pnames):
            if rname not in excl_names and pname not in excl_names:
                net.add_edge(rname, pname, title=eq)

    spc_df.progress_apply(_add_node, axis=1)
    rxn_df.progress_apply(_add_edge, axis=1)
    net.write_html(str(out_dir / out_name), open_browser=True)


# def display_reactions(
#     mech: Mechanism,
#     eqs: Collection | None = None,
#     stereo: bool = True,
#     keys: tuple[str, ...] = (Reactions.eq,),
#     spc_keys: tuple[str, ...] = (Species.smi,),
# ):
#     """Display the reactions in a mechanism.

#     :param mech: _description_
#     :param eqs: _description_, defaults to None
#     :param stereo: _description_, defaults to True
#     :param keys: _description_, defaults to (Reactions.eq,)
#     :param spc_keys: _description_, defaults to (Species.smi,)
#     """
#     pass
